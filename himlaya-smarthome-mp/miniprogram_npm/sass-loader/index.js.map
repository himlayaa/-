{"version":3,"sources":["cjs.js","index.js","formatSassError.js","webpackImporter.js","importsToResolve.js","getSassOptions.js","proxyCustomImporters.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AKfA,AHSA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA;ACFA,AGTA,ADGA,AHSA;ACFA,AGTA,ADGA,AHSA;ACFA,AGTA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,ADGA,AHSA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst loader = require('./index');\n\nmodule.exports = loader.default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _neoAsync = _interopRequireDefault(require(\"neo-async\"));\n\nvar _pify = _interopRequireDefault(require(\"pify\"));\n\nvar _semver = _interopRequireDefault(require(\"semver\"));\n\nvar _loaderUtils = require(\"loader-utils\");\n\nvar _formatSassError = _interopRequireDefault(require(\"./formatSassError\"));\n\nvar _webpackImporter = _interopRequireDefault(require(\"./webpackImporter\"));\n\nvar _getSassOptions = _interopRequireDefault(require(\"./getSassOptions\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet nodeSassJobQueue = null; // Very hacky check\n\nfunction hasGetResolve(loaderContext) {\n  return loaderContext.getResolve && // eslint-disable-next-line no-underscore-dangle\n  loaderContext._compiler && // eslint-disable-next-line no-underscore-dangle\n  loaderContext._compiler.resolverFactory && // eslint-disable-next-line no-underscore-dangle\n  loaderContext._compiler.resolverFactory._create && /cachedCleverMerge/.test( // eslint-disable-next-line no-underscore-dangle\n  loaderContext._compiler.resolverFactory._create.toString());\n}\n/**\n * The sass-loader makes node-sass and dart-sass available to webpack modules.\n *\n * @this {LoaderContext}\n * @param {string} content\n */\n\n\nfunction loader(content) {\n  const options = (0, _loaderUtils.getOptions)(this) || {};\n  const callback = this.async();\n\n  const addNormalizedDependency = file => {\n    // node-sass returns POSIX paths\n    this.dependency(_path.default.normalize(file));\n  };\n\n  if (typeof callback !== 'function') {\n    throw new Error('Synchronous compilation is not supported anymore. See https://github.com/webpack-contrib/sass-loader/issues/333');\n  }\n\n  let resolve = (0, _pify.default)(this.resolve); // Supported since v4.36.0\n\n  if (hasGetResolve(this)) {\n    resolve = this.getResolve({\n      mainFields: ['sass', 'style', 'main', '...'],\n      mainFiles: ['_index', 'index', '...'],\n      extensions: ['.scss', '.sass', '.css', '...']\n    });\n  }\n\n  const sassOptions = (0, _getSassOptions.default)(this, options, content);\n  const shouldUseWebpackImporter = typeof options.webpackImporter === 'boolean' ? options.webpackImporter : true;\n\n  if (shouldUseWebpackImporter) {\n    sassOptions.importer.push((0, _webpackImporter.default)(this.resourcePath, resolve, addNormalizedDependency));\n  } // Skip empty files, otherwise it will stop webpack, see issue #21\n\n\n  if (sassOptions.data.trim() === '') {\n    callback(null, '');\n    return;\n  }\n\n  const render = getRenderFuncFromSassImpl( // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n  options.implementation || getDefaultSassImpl());\n  render(sassOptions, (error, result) => {\n    if (error) {\n      (0, _formatSassError.default)(error, this.resourcePath);\n\n      if (error.file) {\n        this.dependency(error.file);\n      }\n\n      callback(error);\n      return;\n    }\n\n    if (result.map && result.map !== '{}') {\n      // eslint-disable-next-line no-param-reassign\n      result.map = JSON.parse(result.map); // result.map.file is an optional property that provides the output filename.\n      // Since we don't know the final filename in the webpack build chain yet, it makes no sense to have it.\n      // eslint-disable-next-line no-param-reassign\n\n      delete result.map.file; // One of the sources is 'stdin' according to dart-sass/node-sass because we've used the data input.\n      // Now let's override that value with the correct relative path.\n      // Since we specified options.sourceMap = path.join(process.cwd(), \"/sass.map\"); in getSassOptions,\n      // we know that this path is relative to process.cwd(). This is how node-sass works.\n      // eslint-disable-next-line no-param-reassign\n\n      const stdinIndex = result.map.sources.findIndex(source => source.indexOf('stdin') !== -1);\n\n      if (stdinIndex !== -1) {\n        // eslint-disable-next-line no-param-reassign\n        result.map.sources[stdinIndex] = _path.default.relative(process.cwd(), this.resourcePath);\n      } // node-sass returns POSIX paths, that's why we need to transform them back to native paths.\n      // This fixes an error on windows where the source-map module cannot resolve the source maps.\n      // @see https://github.com/webpack-contrib/sass-loader/issues/366#issuecomment-279460722\n      // eslint-disable-next-line no-param-reassign\n\n\n      result.map.sourceRoot = _path.default.normalize(result.map.sourceRoot); // eslint-disable-next-line no-param-reassign\n\n      result.map.sources = result.map.sources.map(_path.default.normalize);\n    } else {\n      // eslint-disable-next-line no-param-reassign\n      result.map = null;\n    }\n\n    result.stats.includedFiles.forEach(addNormalizedDependency);\n    callback(null, result.css.toString(), result.map);\n  });\n}\n/**\n * Verifies that the implementation and version of Sass is supported by this loader.\n *\n * @param {Object} module\n * @returns {Function}\n */\n\n\nfunction getRenderFuncFromSassImpl(module) {\n  const {\n    info\n  } = module;\n\n  if (!info) {\n    throw new Error('Unknown Sass implementation.');\n  }\n\n  const components = info.split('\\t');\n\n  if (components.length < 2) {\n    throw new Error(`Unknown Sass implementation \"${info}\".`);\n  }\n\n  const [implementation, version] = components;\n\n  if (!_semver.default.valid(version)) {\n    throw new Error(`Invalid Sass version \"${version}\".`);\n  }\n\n  if (implementation === 'dart-sass') {\n    if (!_semver.default.satisfies(version, '^1.3.0')) {\n      throw new Error(`Dart Sass version ${version} is incompatible with ^1.3.0.`);\n    }\n\n    return module.render.bind(module);\n  } else if (implementation === 'node-sass') {\n    if (!_semver.default.satisfies(version, '^6.0.1')) {\n      throw new Error(`Node Sass version ${version} is incompatible with ^6.0.1.`);\n    } // There is an issue with node-sass when async custom importers are used\n    // See https://github.com/sass/node-sass/issues/857#issuecomment-93594360\n    // We need to use a job queue to make sure that one thread is always available to the UV lib\n\n\n    if (nodeSassJobQueue === null) {\n      const threadPoolSize = Number(process.env.UV_THREADPOOL_SIZE || 4);\n      nodeSassJobQueue = _neoAsync.default.queue(module.render.bind(module), threadPoolSize - 1);\n    }\n\n    return nodeSassJobQueue.push.bind(nodeSassJobQueue);\n  }\n\n  throw new Error(`Unknown Sass implementation \"${implementation}\".`);\n}\n\nfunction getDefaultSassImpl() {\n  let sassImplPkg = 'node-sass';\n\n  try {\n    require.resolve('node-sass');\n  } catch (error) {\n    try {\n      require.resolve('sass');\n\n      sassImplPkg = 'sass';\n    } catch (ignoreError) {\n      sassImplPkg = 'node-sass';\n    }\n  } // eslint-disable-next-line import/no-dynamic-require, global-require\n\n\n  return require(sassImplPkg);\n}\n\nvar _default = loader;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _os = _interopRequireDefault(require(\"os\"));\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// A typical sass error looks like this\n// const SassError = {\n//   message: \"invalid property name\",\n//   column: 14,\n//   line: 1,\n//   file: \"stdin\",\n//   status: 1\n// };\n\n/**\n * Enhances the sass error with additional information about what actually went wrong.\n *\n * @param {SassError} error\n * @param {string} resourcePath\n */\nfunction formatSassError(error, resourcePath) {\n  // Instruct webpack to hide the JS stack from the console\n  // Usually you're only interested in the SASS stack in this case.\n  // eslint-disable-next-line no-param-reassign\n  error.hideStack = true; // The file property is missing in rare cases.\n  // No improvement in the error is possible.\n\n  if (!error.file) {\n    return;\n  }\n\n  let msg = error.message;\n\n  if (error.file === 'stdin') {\n    // eslint-disable-next-line no-param-reassign\n    error.file = resourcePath;\n  } // node-sass returns UNIX-style paths\n  // eslint-disable-next-line no-param-reassign\n\n\n  error.file = _path.default.normalize(error.file); // The 'Current dir' hint of node-sass does not help us, we're providing\n  // additional information by reading the err.file property\n\n  msg = msg.replace(/\\s*Current dir:\\s*/, ''); // msg = msg.replace(/(\\s*)(stdin)(\\s*)/, `$1${err.file}$3`);\n  // eslint-disable-next-line no-param-reassign\n\n  error.message = `${getFileExcerptIfPossible(error) + msg.charAt(0).toUpperCase() + msg.slice(1) + _os.default.EOL}      in ${error.file} (line ${error.line}, column ${error.column})`;\n}\n/**\n * Tries to get an excerpt of the file where the error happened.\n * Uses err.line and err.column.\n *\n * Returns an empty string if the excerpt could not be retrieved.\n *\n * @param {SassError} error\n * @returns {string}\n */\n\n\nfunction getFileExcerptIfPossible(error) {\n  try {\n    const content = _fs.default.readFileSync(error.file, 'utf8');\n\n    return `${_os.default.EOL + content.split(/\\r?\\n/)[error.line - 1] + _os.default.EOL + new Array(error.column - 1).join(' ')}^${_os.default.EOL}      `;\n  } catch (ignoreError) {\n    // If anything goes wrong here, we don't want any errors to be reported to the user\n    return '';\n  }\n}\n\nvar _default = formatSassError;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _importsToResolve = _interopRequireDefault(require(\"./importsToResolve\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @name PromisedResolve\n * @type {Function}\n * @param {string} dir\n * @param {string} request\n * @returns Promise\n */\n\n/**\n * @name Importer\n * @type {Function}\n * @param {string} url\n * @param {string} prev\n * @param {Function<Error, string>} done\n */\nconst matchCss = /\\.css$/;\n/**\n * Returns an importer that uses webpack's resolving algorithm.\n *\n * It's important that the returned function has the correct number of arguments\n * (based on whether the call is sync or async) because otherwise node-sass doesn't exit.\n *\n * @param {string} resourcePath\n * @param {PromisedResolve} resolve\n * @param {Function<string>} addNormalizedDependency\n * @returns {Importer}\n */\n\nfunction webpackImporter(resourcePath, resolve, addNormalizedDependency) {\n  function dirContextFrom(fileContext) {\n    return _path.default.dirname( // The first file is 'stdin' when we're using the data option\n    fileContext === 'stdin' ? resourcePath : fileContext);\n  } // eslint-disable-next-line no-shadow\n\n\n  function startResolving(dir, importsToResolve) {\n    return importsToResolve.length === 0 ? Promise.reject() : resolve(dir, importsToResolve[0]).then(resolvedFile => {\n      // Add the resolvedFilename as dependency. Although we're also using stats.includedFiles, this might come\n      // in handy when an error occurs. In this case, we don't get stats.includedFiles from node-sass.\n      addNormalizedDependency(resolvedFile);\n      return {\n        // By removing the CSS file extension, we trigger node-sass to include the CSS file instead of just linking it.\n        file: resolvedFile.replace(matchCss, '')\n      };\n    }, () => {\n      const [, ...tailResult] = importsToResolve;\n      return startResolving(dir, tailResult);\n    });\n  }\n\n  return (url, prev, done) => {\n    startResolving(dirContextFrom(prev), (0, _importsToResolve.default)(url)) // Catch all resolving errors, return the original file and pass responsibility back to other custom importers\n    .catch(() => {\n      return {\n        file: url\n      };\n    }).then(done);\n  };\n}\n\nvar _default = webpackImporter;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _loaderUtils = _interopRequireDefault(require(\"loader-utils\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Examples:\n// - ~package\n// - ~package/\n// - ~@org\n// - ~@org/\n// - ~@org/package\n// - ~@org/package/\nconst matchModuleImport = /^~([^/]+|[^/]+\\/|@[^/]+[/][^/]+|@[^/]+\\/?|@[^/]+[/][^/]+\\/)$/;\n/**\n * When libsass tries to resolve an import, it uses a special algorithm.\n * Since the sass-loader uses webpack to resolve the modules, we need to simulate that algorithm. This function\n * returns an array of import paths to try. The last entry in the array is always the original url\n * to enable straight-forward webpack.config aliases.\n *\n * @param {string} url\n * @returns {Array<string>}\n */\n\nfunction importsToResolve(url) {\n  const request = _loaderUtils.default.urlToRequest(url); // Keep in mind: ext can also be something like '.datepicker' when the true extension is omitted and the filename contains a dot.\n  // @see https://github.com/webpack-contrib/sass-loader/issues/167\n\n\n  const ext = _path.default.extname(request); // In case there is module request, send this to webpack resolver\n\n\n  if (matchModuleImport.test(url)) {\n    return [request, url];\n  } // Because @import is also defined in CSS, Sass needs a way of compiling plain CSS @imports without trying to import the files at compile time.\n  // To accomplish this, and to ensure SCSS is as much of a superset of CSS as possible, Sass will compile any @imports with the following characteristics to plain CSS imports:\n  //  - imports where the URL ends with .css.\n  //  - imports where the URL begins http:// or https://.\n  //  - imports where the URL is written as a url().\n  //  - imports that have media queries.\n  //\n  // The `node-sass` package sends `@import` ending on `.css` to importer, it is bug, so we skip resolve\n\n\n  if (ext === '.css') {\n    return [];\n  }\n\n  const dirname = _path.default.dirname(request);\n\n  const basename = _path.default.basename(request); // In case there is file extension:\n  //\n  // 1. Try to resolve `_` file.\n  // 2. Try to resolve file without `_`.\n  // 3. Send a original url to webpack resolver, maybe it is alias.\n\n\n  if (['.scss', '.sass'].includes(ext)) {\n    return [`${dirname}/_${basename}`, `${dirname}/${basename}`, url];\n  } // In case there is no file extension and filename starts with `_`:\n  //\n  // 1. Try to resolve files with `scss`, `sass` and `css` extensions.\n  // 2. Try to resolve directory with `_index` or `index` filename.\n  // 3. Send the original url to webpack resolver, maybe it's alias.\n\n\n  if (basename.charAt(0) === '_') {\n    return [`${request}.scss`, `${request}.sass`, `${request}.css`, request, url];\n  } // In case there is no file extension and filename doesn't start with `_`:\n  //\n  // 1. Try to resolve file starts with `_` and with extensions\n  // 2. Try to resolve file with extensions\n  // 3. Try to resolve directory with `_index` or `index` filename.\n  // 4. Send a original url to webpack resolver, maybe it is alias.\n\n\n  return [`${dirname}/_${basename}.scss`, `${dirname}/_${basename}.sass`, `${dirname}/_${basename}.css`, `${request}.scss`, `${request}.sass`, `${request}.css`, request, url];\n}\n\nvar _default = importsToResolve;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _os = _interopRequireDefault(require(\"os\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _cloneDeep = _interopRequireDefault(require(\"clone-deep\"));\n\nvar _proxyCustomImporters = _interopRequireDefault(require(\"./proxyCustomImporters\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isProductionLikeMode(loaderContext) {\n  return loaderContext.mode === 'production' || !loaderContext.mode || loaderContext.minimize;\n}\n/**\n * Derives the sass options from the loader context and normalizes its values with sane defaults.\n *\n * Please note: If loaderContext.query is an options object, it will be re-used across multiple invocations.\n * That's why we must not modify the object directly.\n *\n * @param {LoaderContext} loaderContext\n * @param {string} loaderOptions\n * @param {object} content\n * @returns {Object}\n */\n\n\nfunction getSassOptions(loaderContext, loaderOptions, content) {\n  const options = (0, _cloneDeep.default)(loaderOptions);\n  const {\n    resourcePath\n  } = loaderContext; // allow opt.functions to be configured WRT loaderContext\n\n  if (typeof options.functions === 'function') {\n    options.functions = options.functions(loaderContext);\n  }\n\n  let {\n    data\n  } = options;\n\n  if (typeof options.data === 'function') {\n    data = options.data(loaderContext);\n  }\n\n  options.data = data ? data + _os.default.EOL + content : content; // opt.outputStyle\n\n  if (!options.outputStyle && isProductionLikeMode(loaderContext)) {\n    options.outputStyle = 'compressed';\n  } // opt.sourceMap\n  // Not using the `this.sourceMap` flag because css source maps are different\n  // @see https://github.com/webpack/css-loader/pull/40\n\n\n  if (options.sourceMap) {\n    // Deliberately overriding the sourceMap option here.\n    // node-sass won't produce source maps if the data option is used and options.sourceMap is not a string.\n    // In case it is a string, options.sourceMap should be a path where the source map is written.\n    // But since we're using the data option, the source map will not actually be written, but\n    // all paths in sourceMap.sources will be relative to that path.\n    // Pretty complicated... :(\n    options.sourceMap = _path.default.join(process.cwd(), '/sass.map');\n\n    if ('sourceMapRoot' in options === false) {\n      options.sourceMapRoot = process.cwd();\n    }\n\n    if ('omitSourceMapUrl' in options === false) {\n      // The source map url doesn't make sense because we don't know the output path\n      // The css-loader will handle that for us\n      options.omitSourceMapUrl = true;\n    }\n\n    if ('sourceMapContents' in options === false) {\n      // If sourceMapContents option is not set, set it to true otherwise maps will be empty/null\n      // when exported by webpack-extract-text-plugin.\n      options.sourceMapContents = true;\n    }\n  } // indentedSyntax is a boolean flag.\n\n\n  const ext = _path.default.extname(resourcePath); // If we are compiling sass and indentedSyntax isn't set, automatically set it.\n\n\n  if (ext && ext.toLowerCase() === '.sass' && 'indentedSyntax' in options === false) {\n    options.indentedSyntax = true;\n  } else {\n    options.indentedSyntax = Boolean(options.indentedSyntax);\n  } // Allow passing custom importers to `node-sass`. Accepts `Function` or an array of `Function`s.\n\n\n  options.importer = options.importer ? (0, _proxyCustomImporters.default)(options.importer, resourcePath) : []; // `node-sass` uses `includePaths` to resolve `@import` paths. Append the currently processed file.\n\n  options.includePaths = options.includePaths || [];\n  options.includePaths.push(_path.default.dirname(resourcePath));\n  return options;\n}\n\nvar _default = getSassOptions;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * Creates new custom importers that use the given `resourcePath` if libsass calls the custom importer with `prev`\n * being 'stdin'.\n *\n * Why do we need this? We have to use the `data` option of node-sass in order to compile our sass because\n * the `resourcePath` might not be an actual file on disk. When using the `data` option, libsass uses the string\n * 'stdin' instead of a filename.\n *\n * We have to fix this behavior in order to provide a consistent experience to the webpack user.\n *\n * @param {Function|Array<Function>} importer\n * @param {string} resourcePath\n * @returns {Array<Function>}\n */\nfunction proxyCustomImporters(importer, resourcePath) {\n  return [].concat(importer).map( // eslint-disable-next-line no-shadow\n  importer => function customImporter() {\n    return importer.apply(this, // eslint-disable-next-line prefer-rest-params\n    Array.from(arguments).map((arg, i) => i === 1 && arg === 'stdin' ? resourcePath : arg));\n  });\n}\n\nvar _default = proxyCustomImporters;\nexports.default = _default;"]}