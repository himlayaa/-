{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst isPlainObject = require('is-plain-obj');\nconst arrify = require('arrify');\nconst kindOf = require('kind-of');\n\nconst push = (obj, prop, value) => {\n\tif (!obj[prop]) {\n\t\tobj[prop] = [];\n\t}\n\n\tobj[prop].push(value);\n};\n\nconst insert = (obj, prop, key, value) => {\n\tif (!obj[prop]) {\n\t\tobj[prop] = {};\n\t}\n\n\tobj[prop][key] = value;\n};\n\nconst prettyPrint = output => {\n\treturn Array.isArray(output) ?\n\t\t`[${output.map(prettyPrint).join(', ')}]` :\n\t\tkindOf(output) === 'string' ? JSON.stringify(output) : output;\n};\n\nconst resolveType = value => {\n\tif (Array.isArray(value) && value.length > 0) {\n\t\tconst [element] = value;\n\t\treturn `${kindOf(element)}-array`;\n\t}\n\n\treturn kindOf(value);\n};\n\nconst normalizeExpectedType = (type, defaultValue) => {\n\tconst inferredType = type === 'array' ? 'string-array' : type;\n\n\tif (arrayTypes.includes(inferredType) && Array.isArray(defaultValue) && defaultValue.length === 0) {\n\t\treturn 'array';\n\t}\n\n\treturn inferredType;\n};\n\nconst passthroughOptions = ['stopEarly', 'unknown', '--'];\nconst primitiveTypes = ['string', 'boolean', 'number'];\nconst arrayTypes = primitiveTypes.map(t => `${t}-array`);\nconst availableTypes = [...primitiveTypes, 'array', ...arrayTypes];\n\nconst buildOptions = options => {\n\toptions = options || {};\n\n\tconst result = {};\n\n\tpassthroughOptions.forEach(key => {\n\t\tif (options[key]) {\n\t\t\tresult[key] = options[key];\n\t\t}\n\t});\n\n\tObject.keys(options).forEach(key => {\n\t\tlet value = options[key];\n\n\t\tif (key === 'arguments') {\n\t\t\tkey = '_';\n\t\t}\n\n\t\t// If short form is used\n\t\t// convert it to long form\n\t\t// e.g. { 'name': 'string' }\n\t\tif (typeof value === 'string') {\n\t\t\tvalue = {type: value};\n\t\t}\n\n\t\tif (isPlainObject(value)) {\n\t\t\tconst props = value;\n\t\t\tconst {type} = props;\n\n\t\t\tif (type) {\n\t\t\t\tif (!availableTypes.includes(type)) {\n\t\t\t\t\tthrow new TypeError(`Expected type of \"${key}\" to be one of ${prettyPrint(availableTypes)}, got ${prettyPrint(type)}`);\n\t\t\t\t}\n\n\t\t\t\tif (arrayTypes.includes(type)) {\n\t\t\t\t\tconst [elementType] = type.split('-');\n\t\t\t\t\tpush(result, 'array', {key, [elementType]: true});\n\t\t\t\t} else {\n\t\t\t\t\tpush(result, type, key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ({}.hasOwnProperty.call(props, 'default')) {\n\t\t\t\tconst {default: defaultValue} = props;\n\t\t\t\tconst defaultType = resolveType(defaultValue);\n\t\t\t\tconst expectedType = normalizeExpectedType(type, defaultValue);\n\n\t\t\t\tif (expectedType && expectedType !== defaultType) {\n\t\t\t\t\tthrow new TypeError(`Expected \"${key}\" default value to be of type \"${expectedType}\", got ${prettyPrint(defaultType)}`);\n\t\t\t\t}\n\n\t\t\t\tinsert(result, 'default', key, defaultValue);\n\t\t\t}\n\n\t\t\tarrify(props.alias).forEach(alias => {\n\t\t\t\tinsert(result, 'alias', alias, key);\n\t\t\t});\n\t\t}\n\t});\n\n\treturn result;\n};\n\nmodule.exports = buildOptions;\nmodule.exports.default = buildOptions;\n"]}