{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst path = require('path');\nconst buildParserOptions = require('minimist-options');\nconst parseArguments = require('yargs-parser');\nconst camelCaseKeys = require('camelcase-keys');\nconst decamelize = require('decamelize');\nconst decamelizeKeys = require('decamelize-keys');\nconst trimNewlines = require('trim-newlines');\nconst redent = require('redent');\nconst readPkgUp = require('read-pkg-up');\nconst hardRejection = require('hard-rejection');\nconst normalizePackageData = require('normalize-package-data');\n\n// Prevent caching of this module so module.parent is always accurate\ndelete require.cache[__filename];\nconst parentDir = path.dirname(module.parent && module.parent.filename ? module.parent.filename : '.');\n\nconst isFlagMissing = (flagName, definedFlags, receivedFlags, input) => {\n\tconst flag = definedFlags[flagName];\n\tlet isFlagRequired = true;\n\n\tif (typeof flag.isRequired === 'function') {\n\t\tisFlagRequired = flag.isRequired(receivedFlags, input);\n\t\tif (typeof isFlagRequired !== 'boolean') {\n\t\t\tthrow new TypeError(`Return value for isRequired callback should be of type boolean, but ${typeof isFlagRequired} was returned.`);\n\t\t}\n\t}\n\n\tif (typeof receivedFlags[flagName] === 'undefined') {\n\t\treturn isFlagRequired;\n\t}\n\n\treturn flag.isMultiple && receivedFlags[flagName].length === 0;\n};\n\nconst getMissingRequiredFlags = (flags, receivedFlags, input) => {\n\tconst missingRequiredFlags = [];\n\tif (typeof flags === 'undefined') {\n\t\treturn [];\n\t}\n\n\tfor (const flagName of Object.keys(flags)) {\n\t\tif (flags[flagName].isRequired && isFlagMissing(flagName, flags, receivedFlags, input)) {\n\t\t\tmissingRequiredFlags.push({key: flagName, ...flags[flagName]});\n\t\t}\n\t}\n\n\treturn missingRequiredFlags;\n};\n\nconst reportMissingRequiredFlags = missingRequiredFlags => {\n\tconsole.error(`Missing required flag${missingRequiredFlags.length > 1 ? 's' : ''}`);\n\tfor (const flag of missingRequiredFlags) {\n\t\tconsole.error(`\\t--${decamelize(flag.key, '-')}${flag.alias ? `, -${flag.alias}` : ''}`);\n\t}\n};\n\nconst validateOptions = ({flags}) => {\n\tconst invalidFlags = Object.keys(flags).filter(flagKey => flagKey.includes('-') && flagKey !== '--');\n\tif (invalidFlags.length > 0) {\n\t\tthrow new Error(`Flag keys may not contain '-': ${invalidFlags.join(', ')}`);\n\t}\n};\n\nconst reportUnknownFlags = unknownFlags => {\n\tconsole.error([\n\t\t`Unknown flag${unknownFlags.length > 1 ? 's' : ''}`,\n\t\t...unknownFlags\n\t].join('\\n'));\n};\n\nconst buildParserFlags = ({flags, booleanDefault}) => {\n\tconst parserFlags = {};\n\n\tfor (const [flagKey, flagValue] of Object.entries(flags)) {\n\t\tconst flag = {...flagValue};\n\n\t\tif (\n\t\t\ttypeof booleanDefault !== 'undefined' &&\n\t\t\tflag.type === 'boolean' &&\n\t\t\t!Object.prototype.hasOwnProperty.call(flag, 'default')\n\t\t) {\n\t\t\tflag.default = flag.isMultiple ? [booleanDefault] : booleanDefault;\n\t\t}\n\n\t\tif (flag.isMultiple) {\n\t\t\tflag.type = flag.type ? `${flag.type}-array` : 'array';\n\t\t\tflag.default = flag.default || [];\n\t\t\tdelete flag.isMultiple;\n\t\t}\n\n\t\tparserFlags[flagKey] = flag;\n\t}\n\n\treturn parserFlags;\n};\n\nconst validateFlags = (flags, options) => {\n\tfor (const [flagKey, flagValue] of Object.entries(options.flags)) {\n\t\tif (flagKey !== '--' && !flagValue.isMultiple && Array.isArray(flags[flagKey])) {\n\t\t\tthrow new Error(`The flag --${flagKey} can only be set once.`);\n\t\t}\n\t}\n};\n\nconst meow = (helpText, options) => {\n\tif (typeof helpText !== 'string') {\n\t\toptions = helpText;\n\t\thelpText = '';\n\t}\n\n\tconst foundPkg = readPkgUp.sync({\n\t\tcwd: parentDir,\n\t\tnormalize: false\n\t});\n\n\toptions = {\n\t\tpkg: foundPkg ? foundPkg.packageJson : {},\n\t\targv: process.argv.slice(2),\n\t\tflags: {},\n\t\tinferType: false,\n\t\tinput: 'string',\n\t\thelp: helpText,\n\t\tautoHelp: true,\n\t\tautoVersion: true,\n\t\tbooleanDefault: false,\n\t\thardRejection: true,\n\t\tallowUnknownFlags: true,\n\t\t...options\n\t};\n\n\tif (options.hardRejection) {\n\t\thardRejection();\n\t}\n\n\tvalidateOptions(options);\n\tlet parserOptions = {\n\t\targuments: options.input,\n\t\t...buildParserFlags(options)\n\t};\n\n\tparserOptions = decamelizeKeys(parserOptions, '-', {exclude: ['stopEarly', '--']});\n\n\tif (options.inferType) {\n\t\tdelete parserOptions.arguments;\n\t}\n\n\tparserOptions = buildParserOptions(parserOptions);\n\n\tparserOptions.configuration = {\n\t\t...parserOptions.configuration,\n\t\t'greedy-arrays': false\n\t};\n\n\tif (parserOptions['--']) {\n\t\tparserOptions.configuration['populate--'] = true;\n\t}\n\n\tif (!options.allowUnknownFlags) {\n\t\t// Collect unknown options in `argv._` to be checked later.\n\t\tparserOptions.configuration['unknown-options-as-args'] = true;\n\t}\n\n\tconst {pkg} = options;\n\tconst argv = parseArguments(options.argv, parserOptions);\n\tlet help = redent(trimNewlines((options.help || '').replace(/\\t+\\n*$/, '')), 2);\n\n\tnormalizePackageData(pkg);\n\n\tprocess.title = pkg.bin ? Object.keys(pkg.bin)[0] : pkg.name;\n\n\tlet {description} = options;\n\tif (!description && description !== false) {\n\t\t({description} = pkg);\n\t}\n\n\thelp = (description ? `\\n  ${description}\\n` : '') + (help ? `\\n${help}\\n` : '\\n');\n\n\tconst showHelp = code => {\n\t\tconsole.log(help);\n\t\tprocess.exit(typeof code === 'number' ? code : 2);\n\t};\n\n\tconst showVersion = () => {\n\t\tconsole.log(typeof options.version === 'string' ? options.version : pkg.version);\n\t\tprocess.exit(0);\n\t};\n\n\tif (argv._.length === 0 && options.argv.length === 1) {\n\t\tif (argv.version === true && options.autoVersion) {\n\t\t\tshowVersion();\n\t\t}\n\n\t\tif (argv.help === true && options.autoHelp) {\n\t\t\tshowHelp(0);\n\t\t}\n\t}\n\n\tconst input = argv._;\n\tdelete argv._;\n\n\tif (!options.allowUnknownFlags) {\n\t\tconst unknownFlags = input.filter(item => typeof item === 'string' && item.startsWith('-'));\n\t\tif (unknownFlags.length > 0) {\n\t\t\treportUnknownFlags(unknownFlags);\n\t\t\tprocess.exit(2);\n\t\t}\n\t}\n\n\tconst flags = camelCaseKeys(argv, {exclude: ['--', /^\\w$/]});\n\tconst unnormalizedFlags = {...flags};\n\n\tvalidateFlags(flags, options);\n\n\tfor (const flagValue of Object.values(options.flags)) {\n\t\tdelete flags[flagValue.alias];\n\t}\n\n\tconst missingRequiredFlags = getMissingRequiredFlags(options.flags, flags, input);\n\tif (missingRequiredFlags.length > 0) {\n\t\treportMissingRequiredFlags(missingRequiredFlags);\n\t\tprocess.exit(2);\n\t}\n\n\treturn {\n\t\tinput,\n\t\tflags,\n\t\tunnormalizedFlags,\n\t\tpkg,\n\t\thelp,\n\t\tshowHelp,\n\t\tshowVersion\n\t};\n};\n\nmodule.exports = meow;\n"]}