{"version":3,"sources":["globule.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n * globule\n * https://github.com/cowboy/node-globule\n *\n * Copyright (c) 2018 \"Cowboy\" Ben Alman\n * Licensed under the MIT license.\n */\n\n\n\nvar fs = require('fs');\nvar path = require('path');\n\nvar _ = require('lodash');\nvar glob = require('glob');\nvar minimatch = require('minimatch');\n\n// The module.\nvar globule = exports;\n\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nfunction processPatterns(patterns, options, fn) {\n  var result = [];\n  _.each(patterns, function(pattern) {\n    // The first character is not ! (inclusion). Add all matching filepaths\n    // to the result set.\n    if (pattern.indexOf('!') !== 0) {\n      result = _.union(result, fn(pattern));\n      return;\n    }\n    // The first character is ! (exclusion). Remove any filepaths from the\n    // result set that match this pattern, sans leading !.\n    var filterFn = minimatch.filter(pattern.slice(1), options);\n    result = _.filter(result, function(filepath) {\n      return !filterFn(filepath);\n    });\n  });\n  return result;\n}\n\n// Normalize paths to be unix-style.\nvar pathSeparatorRe = /[\\/\\\\]/g;\nfunction normalizePath(path) {\n  return path.replace(pathSeparatorRe, '/');\n}\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// all matching filepaths. This behaves just like minimatch.match, but supports\n// any number of patterns.\nglobule.match = function(patterns, filepaths, options) {\n  // Return empty set if either patterns or filepaths was omitted.\n  if (patterns == null || filepaths == null) { return []; }\n  // Normalize patterns and filepaths to flattened arrays.\n  patterns = _.isArray(patterns) ? _.flattenDeep(patterns) : [patterns];\n  filepaths = _.isArray(filepaths) ? _.flattenDeep(filepaths) : [filepaths];\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0 || filepaths.length === 0) { return []; }\n  // Return all matching filepaths.\n  return processPatterns(patterns, options, function(pattern) {\n    return minimatch.match(filepaths, pattern, options || {});\n  });\n};\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// true if any of the patterns match.\nglobule.isMatch = function() {\n  return globule.match.apply(null, arguments).length > 0;\n};\n\n// Return an array of all file paths that match the given wildcard patterns.\nglobule.find = function() {\n  var args = _.toArray(arguments);\n  // If the last argument is an options object, remove it from args.\n  var options = _.isPlainObject(args[args.length - 1]) ? args.pop() : {};\n  // If options.src was specified, use it. Otherwise, use all non-options\n  // arguments. Flatten nested arrays.\n  var patterns;\n  if (options.src) {\n    patterns = _.isArray(options.src) ? _.flattenDeep(options.src) : [options.src];\n  } else {\n    patterns = _.flattenDeep(args);\n  }\n  // Return empty set if there are no patterns.\n  if (patterns.length === 0) { return []; }\n  var srcBase = options.srcBase || options.cwd;\n  // Create glob-specific options object.\n  var globOptions = _.extend({}, options);\n  if (srcBase) {\n    globOptions.cwd = srcBase;\n  }\n  // Get all matching filepaths.\n  var matches = processPatterns(patterns, options, function(pattern) {\n    return glob.sync(pattern, globOptions);\n  });\n  // If srcBase and prefixBase were specified, prefix srcBase to matched paths.\n  if (srcBase && options.prefixBase) {\n    matches = matches.map(function(filepath) {\n      return normalizePath(path.join(srcBase, filepath));\n    });\n  }\n  // Filter result set?\n  if (options.filter) {\n    matches = matches.filter(function(filepath) {\n      // If srcBase was specified but prefixBase was NOT, prefix srcBase\n      // temporarily, for filtering.\n      if (srcBase && !options.prefixBase) {\n        filepath = normalizePath(path.join(srcBase, filepath));\n      }\n      try {\n        if (_.isFunction(options.filter)) {\n          return options.filter(filepath, options);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch(err) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n  return matches;\n};\n\nvar extDotRe = {\n  first: /(\\.[^\\/]*)?$/,\n  last: /(\\.[^\\/\\.]*)?$/,\n};\nfunction rename(dest, options) {\n  // Flatten path?\n  if (options.flatten) {\n    dest = path.basename(dest);\n  }\n  // Change the extension?\n  if (options.ext) {\n    dest = dest.replace(extDotRe[options.extDot], options.ext);\n  }\n  // Join dest and destBase?\n  if (options.destBase) {\n    dest = path.join(options.destBase, dest);\n  }\n  return dest;\n}\n\n// Build a mapping of src-dest filepaths from the given set of filepaths.\nglobule.mapping = function(filepaths, options) {\n  // Return empty set if filepaths was omitted.\n  if (filepaths == null) { return []; }\n  options = _.defaults({}, options, {\n    extDot: 'first',\n    rename: rename,\n  });\n  var files = [];\n  var fileByDest = {};\n  // Find all files matching pattern, using passed-in options.\n  filepaths.forEach(function(src) {\n    // Generate destination filename.\n    var dest = options.rename(src, options);\n    // Prepend srcBase to all src paths.\n    if (options.srcBase) {\n      src = path.join(options.srcBase, src);\n    }\n    // Normalize filepaths to be unix-style.\n    dest = normalizePath(dest);\n    src = normalizePath(src);\n    // Map correct src path to dest path.\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest,\n      });\n      // And store a reference for later use.\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n};\n\n// Return a mapping of src-dest filepaths from files matching the given\n// wildcard patterns.\nglobule.findMapping = function() {\n  var args = _.toArray(arguments);\n  // If the last argument is an options object, remove it from args.\n  var options = _.isPlainObject(args[args.length - 1]) ? args.pop() : {};\n  // Generate mapping from found filepaths.\n  return globule.mapping(globule.find(args, options), options);\n};\n"]}