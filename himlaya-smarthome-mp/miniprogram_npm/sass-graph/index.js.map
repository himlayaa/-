{"version":3,"sources":["sass-graph.js","parse-imports.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar fs = require('fs');\nvar path = require('path');\nvar _ = require('lodash');\nvar glob = require('glob');\nvar parseImports = require('./parse-imports');\n\n// resolve a sass module to a path\nfunction resolveSassPath(sassPath, loadPaths, extensions) {\n  // trim sass file extensions\n  var re = new RegExp('(\\.('+extensions.join('|')+'))$', 'i');\n  var sassPathName = sassPath.replace(re, '');\n  // check all load paths\n  var i, j, length = loadPaths.length, scssPath, partialPath;\n  for (i = 0; i < length; i++) {\n    for (j = 0; j < extensions.length; j++) {\n      scssPath = path.normalize(loadPaths[i] + '/' + sassPathName + '.' + extensions[j]);\n      try {\n        if (fs.lstatSync(scssPath).isFile()) {\n          return scssPath;\n        }\n      } catch (e) {}\n    }\n\n    // special case for _partials\n    for (j = 0; j < extensions.length; j++) {\n      scssPath = path.normalize(loadPaths[i] + '/' + sassPathName + '.' + extensions[j]);\n      partialPath = path.join(path.dirname(scssPath), '_' + path.basename(scssPath));\n      try {\n        if (fs.lstatSync(partialPath).isFile()) {\n          return partialPath;\n        }\n      } catch (e) {}\n    }\n  }\n\n  // File to import not found or unreadable so we assume this is a custom import\n  return false;\n}\n\nfunction Graph(options, dir) {\n  this.dir = dir;\n  this.extensions = options.extensions || [];\n  this.index = {};\n  this.follow = options.follow || false;\n  this.loadPaths = _(options.loadPaths).map(function(p) {\n    return path.resolve(p);\n  }).value();\n\n  if (dir) {\n    var graph = this;\n    _.each(glob.sync(dir+'/**/*.@('+this.extensions.join('|')+')', { dot: true, nodir: true, follow: this.follow }), function(file) {\n      graph.addFile(path.resolve(file));\n    });\n  }\n}\n\n// add a sass file to the graph\nGraph.prototype.addFile = function(filepath, parent) {\n  var entry = this.index[filepath] = this.index[filepath] || {\n    imports: [],\n    importedBy: [],\n    modified: fs.statSync(filepath).mtime\n  };\n\n  var resolvedParent;\n  var isIndentedSyntax = path.extname(filepath) === '.sass';\n  var imports = parseImports(fs.readFileSync(filepath, 'utf-8'), isIndentedSyntax);\n  var cwd = path.dirname(filepath);\n\n  var i, length = imports.length, loadPaths, resolved;\n  for (i = 0; i < length; i++) {\n    loadPaths = _([cwd, this.dir]).concat(this.loadPaths).filter().uniq().value();\n    resolved = resolveSassPath(imports[i], loadPaths, this.extensions);\n    if (!resolved) continue;\n\n    // recurse into dependencies if not already enumerated\n    if (!_.includes(entry.imports, resolved)) {\n      entry.imports.push(resolved);\n      this.addFile(fs.realpathSync(resolved), filepath);\n    }\n  }\n\n  // add link back to parent\n  if (parent) {\n    resolvedParent = _(parent).intersection(this.loadPaths).value();\n\n    if (resolvedParent) {\n      resolvedParent = parent.substr(parent.indexOf(resolvedParent));\n    } else {\n      resolvedParent = parent;\n    }\n\n    entry.importedBy.push(resolvedParent);\n  }\n};\n\n// visits all files that are ancestors of the provided file\nGraph.prototype.visitAncestors = function(filepath, callback) {\n  this.visit(filepath, callback, function(err, node) {\n    if (err || !node) return [];\n    return node.importedBy;\n  });\n};\n\n// visits all files that are descendents of the provided file\nGraph.prototype.visitDescendents = function(filepath, callback) {\n  this.visit(filepath, callback, function(err, node) {\n    if (err || !node) return [];\n    return node.imports;\n  });\n};\n\n// a generic visitor that uses an edgeCallback to find the edges to traverse for a node\nGraph.prototype.visit = function(filepath, callback, edgeCallback, visited) {\n  filepath = fs.realpathSync(filepath);\n  var visited = visited || [];\n  if (!this.index.hasOwnProperty(filepath)) {\n    edgeCallback('Graph doesn\\'t contain ' + filepath, null);\n  }\n  var edges = edgeCallback(null, this.index[filepath]);\n\n  var i, length = edges.length;\n  for (i = 0; i < length; i++) {\n    if (!_.includes(visited, edges[i])) {\n      visited.push(edges[i]);\n      callback(edges[i], this.index[edges[i]]);\n      this.visit(edges[i], callback, edgeCallback, visited);\n    }\n  }\n};\n\nfunction processOptions(options) {\n  return _.assign({\n    loadPaths: [process.cwd()],\n    extensions: ['scss', 'css', 'sass'],\n  }, options);\n}\n\nmodule.exports.parseFile = function(filepath, options) {\n  if (fs.lstatSync(filepath).isFile()) {\n    filepath = path.resolve(filepath);\n    options = processOptions(options);\n    var graph = new Graph(options);\n    graph.addFile(filepath);\n    return graph;\n  }\n  // throws\n};\n\nmodule.exports.parseDir = function(dirpath, options) {\n  if (fs.lstatSync(dirpath).isDirectory()) {\n    dirpath = path.resolve(dirpath);\n    options = processOptions(options);\n    var graph = new Graph(options, dirpath);\n    return graph;\n  }\n  // throws\n};\n","var tokenizer = require('scss-tokenizer');\n\nfunction parseImports(content, isIndentedSyntax) {\n  var tokens = tokenizer.tokenize(content);\n  var results = [];\n  var tmp = '';\n  var inImport = false;\n  var inParen = false;\n  var prevToken = tokens[0];\n\n  var i, token;\n  for (i = 1; i < tokens.length; i++) {\n    token = tokens[i];\n\n    if (inImport && !inParen && token[0] === 'string') {\n      results.push(token[1]);\n    }\n    else if (token[1] === 'import' && prevToken[1] === '@') {\n      if (inImport && !isIndentedSyntax) {\n        throw new Error('Encountered invalid @import syntax.');\n      }\n\n      inImport = true;\n    }\n    else if (inImport && !inParen && (token[0] === 'ident' || token[0] === '/')) {\n      tmp += token[1];\n    }\n    else if (inImport && !inParen && (token[0] === 'space' || token[0] === 'newline')) {\n      if (tmp !== '') {\n        results.push(tmp);\n        tmp = '';\n\n        if (isIndentedSyntax) {\n          inImport = false;\n        }\n      }\n    }\n    else if (inImport && token[0] === ';') {\n      inImport = false;\n\n      if (tmp !== '') {\n        results.push(tmp);\n        tmp = '';\n      }\n    }\n    else if (inImport && token[0] === '(') {\n      inParen = true;\n      tmp = '';\n    }\n    else if (inParen && token[0] === ')') {\n      inParen = false;\n    }\n\n    prevToken = token;\n  }\n\n  if (tmp !== '') {\n    results.push(tmp);\n  }\n\n  return results;\n}\n\nmodule.exports = parseImports;\n"]}