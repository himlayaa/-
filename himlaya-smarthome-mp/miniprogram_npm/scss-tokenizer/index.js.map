{"version":3,"sources":["index.js","lib/entry.js","lib/input.js","lib/previous-map.js","lib/tokenize.js","lib/tokenize-string.js","lib/tokenize-interpolant.js","lib/tokenize-comment.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;;ACDA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AIZA,ADGA,ADGA,ADGA;AHUA,ACHA,ACHA,AIZA,ADGA,ADGA,ADGA;AHUA,ACHA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;AFOA,ACHA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;ADIA,AIZA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AGRA,ADGA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./lib/entry').default;\n","\n\nexports.__esModule = true;\n\nvar _input = require('./input');\n\nvar _input2 = _interopRequireDefault(_input);\n\nvar _tokenize = require('./tokenize');\n\nvar _tokenize2 = _interopRequireDefault(_tokenize);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar scss = {};\nscss.tokenize = function (css) {\n    var input = new _input2.default(css);\n    return (0, _tokenize2.default)(input);\n};\n\nexports.default = scss;","\n\nexports.__esModule = true;\n\nvar _previousMap = require('./previous-map');\n\nvar _previousMap2 = _interopRequireDefault(_previousMap);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar sequence = 0;\n\nvar Input = function () {\n    function Input(css) {\n        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Input);\n\n        this.css = css.toString();\n\n        if (this.css[0] === '\\uFEFF' || this.css[0] === '\\uFFFE') {\n            this.css = this.css.slice(1);\n        }\n\n        if (opts.from) this.file = _path2.default.resolve(opts.from);\n\n        var map = new _previousMap2.default(this.css, opts, this.id);\n        if (map.text) {\n            this.map = map;\n            var file = map.consumer().file;\n            if (!this.file && file) this.file = this.mapResolve(file);\n        }\n\n        if (this.file) {\n            this.from = this.file;\n        } else {\n            sequence += 1;\n            this.id = '<input css ' + sequence + '>';\n            this.from = this.id;\n        }\n        if (this.map) this.map.file = this.from;\n    }\n\n    Input.prototype.mapResolve = function mapResolve(file) {\n        return _path2.default.resolve(this.map.consumer().sourceRoot || '.', file);\n    };\n\n    return Input;\n}();\n\nexports.default = Input;","\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _jsBase = require('js-base64');\n\nvar _sourceMap = require('source-map');\n\nvar _sourceMap2 = _interopRequireDefault(_sourceMap);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PreviousMap = function () {\n    function PreviousMap(css, opts) {\n        _classCallCheck(this, PreviousMap);\n\n        this.loadAnnotation(css);\n        this.inline = this.startWith(this.annotation, 'data:');\n\n        var prev = opts.map ? opts.map.prev : undefined;\n        var text = this.loadMap(opts.from, prev);\n        if (text) this.text = text;\n    }\n\n    PreviousMap.prototype.consumer = function consumer() {\n        if (!this.consumerCache) {\n            this.consumerCache = new _sourceMap2.default.SourceMapConsumer(this.text);\n        }\n        return this.consumerCache;\n    };\n\n    PreviousMap.prototype.withContent = function withContent() {\n        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    };\n\n    PreviousMap.prototype.startWith = function startWith(string, start) {\n        if (!string) return false;\n        return string.substr(0, start.length) === start;\n    };\n\n    PreviousMap.prototype.loadAnnotation = function loadAnnotation(css) {\n        var match = css.match(/\\/\\*\\s*# sourceMappingURL=(.*)\\s*\\*\\//);\n        if (match) this.annotation = match[1].trim();\n    };\n\n    PreviousMap.prototype.decodeInline = function decodeInline(text) {\n        var uri = 'data:application/json,';\n        var base64 = 'data:application/json;base64,';\n\n        if (this.startWith(text, uri)) {\n            return decodeURIComponent(text.substr(uri.length));\n        } else if (this.startWith(text, base64)) {\n            return _jsBase.Base64.decode(text.substr(base64.length));\n        } else {\n            var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n            throw new Error('Unsupported source map encoding ' + encoding);\n        }\n    };\n\n    PreviousMap.prototype.loadMap = function loadMap(file, prev) {\n        if (prev === false) return false;\n\n        if (prev) {\n            if (typeof prev === 'string') {\n                return prev;\n            } else if (prev instanceof _sourceMap2.default.SourceMapConsumer) {\n                return _sourceMap2.default.SourceMapGenerator.fromSourceMap(prev).toString();\n            } else if (prev instanceof _sourceMap2.default.SourceMapGenerator) {\n                return prev.toString();\n            } else if ((typeof prev === 'undefined' ? 'undefined' : _typeof(prev)) === 'object' && prev.mappings) {\n                return JSON.stringify(prev);\n            } else {\n                throw new Error('Unsupported previous source map format: ' + prev.toString());\n            }\n        } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n        } else if (this.annotation) {\n            var map = this.annotation;\n            if (file) map = _path2.default.join(_path2.default.dirname(file), map);\n\n            this.root = _path2.default.dirname(map);\n            if (_fs2.default.existsSync && _fs2.default.existsSync(map)) {\n                return _fs2.default.readFileSync(map, 'utf-8').toString().trim();\n            } else {\n                return false;\n            }\n        }\n    };\n\n    return PreviousMap;\n}();\n\nexports.default = PreviousMap;","\n\nexports.__esModule = true;\nexports.default = tokenize;\n\nvar _input = require('./input');\n\nvar _input2 = _interopRequireDefault(_input);\n\nvar _tokenizeString2 = require('./tokenize-string');\n\nvar _tokenizeString3 = _interopRequireDefault(_tokenizeString2);\n\nvar _tokenizeComment2 = require('./tokenize-comment');\n\nvar _tokenizeComment3 = _interopRequireDefault(_tokenizeComment2);\n\nvar _tokenizeInterpolant2 = require('./tokenize-interpolant');\n\nvar _tokenizeInterpolant3 = _interopRequireDefault(_tokenizeInterpolant2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar singleQuote = \"'\".charCodeAt(0),\n    doubleQuote = '\"'.charCodeAt(0),\n    dollar = '$'.charCodeAt(0),\n    hash = '#'.charCodeAt(0),\n    backslash = '\\\\'.charCodeAt(0),\n    slash = '/'.charCodeAt(0),\n    newline = '\\n'.charCodeAt(0),\n    space = ' '.charCodeAt(0),\n    feed = '\\f'.charCodeAt(0),\n    tab = '\\t'.charCodeAt(0),\n    cr = '\\r'.charCodeAt(0),\n    openBracket = '('.charCodeAt(0),\n    closeBracket = ')'.charCodeAt(0),\n    openCurly = '{'.charCodeAt(0),\n    closeCurly = '}'.charCodeAt(0),\n    semicolon = ';'.charCodeAt(0),\n    asterisk = '*'.charCodeAt(0),\n    colon = ':'.charCodeAt(0),\n    at = '@'.charCodeAt(0),\n    comma = ','.charCodeAt(0),\n    plus = '+'.charCodeAt(0),\n    minus = '-'.charCodeAt(0),\n    decComb = '>'.charCodeAt(0),\n    adjComb = '~'.charCodeAt(0),\n    number = /[+-]?(\\d+(\\.\\d+)?|\\.\\d+)|(e[+-]\\d+)/gi,\n    sQuoteEnd = /(.*?)[^\\\\](?=((#{)|'))/gm,\n    dQuoteEnd = /(.*?)[^\\\\](?=((#{)|\"))/gm,\n    wordEnd = /[ \\n\\t\\r\\(\\)\\{\\},:;@!'\"\\\\]|\\/(?=\\*)|#(?={)/g,\n    ident = /-?([a-z_]|\\\\[^\\\\])([a-z-_0-9]|\\\\[^\\\\])*/gi;\n\nfunction tokenize(input, l, p) {\n    var tokens = [];\n    var css = input.css.valueOf();\n\n    var code = void 0,\n        next = void 0,\n        quote = void 0,\n        lines = void 0,\n        last = void 0,\n        content = void 0,\n        escape = void 0,\n        nextLine = void 0,\n        nextOffset = void 0,\n        escaped = void 0,\n        escapePos = void 0,\n        inInterpolant = void 0,\n        inComment = void 0,\n        inString = void 0;\n\n    var length = css.length;\n    var offset = -1;\n    var line = l || 1;\n    var pos = p || 0;\n\n    while (pos < length) {\n        code = css.charCodeAt(pos);\n\n        if (code === newline) {\n            offset = pos;\n            line += 1;\n        }\n\n        switch (code) {\n            case space:\n            case tab:\n            case cr:\n            case feed:\n                next = pos;\n                do {\n                    next += 1;\n                    code = css.charCodeAt(next);\n                    if (code === newline) {\n                        offset = next;\n                        line += 1;\n                    }\n                } while (code === space || code === tab || code === cr || code === feed);\n\n                tokens.push(['space', css.slice(pos, next)]);\n                pos = next - 1;\n                break;\n\n            case newline:\n                tokens.push(['newline', '\\n', line, pos - offset]);\n                break;\n\n            case plus:\n                tokens.push(['+', '+', line, pos - offset]);\n                break;\n\n            case minus:\n                tokens.push(['-', '-', line, pos - offset]);\n                break;\n\n            case decComb:\n                tokens.push(['>', '>', line, pos - offset]);\n                break;\n\n            case adjComb:\n                tokens.push(['~', '~', line, pos - offset]);\n                break;\n\n            case openCurly:\n                tokens.push(['{', '{', line, pos - offset]);\n                break;\n\n            case closeCurly:\n                if (inInterpolant) {\n                    inInterpolant = false;\n                    tokens.push(['endInterpolant', '}', line, pos - offset]);\n                } else {\n                    tokens.push(['}', '}', line, pos - offset]);\n                }\n                break;\n\n            case comma:\n                tokens.push([',', ',', line, pos - offset]);\n                break;\n\n            case dollar:\n                tokens.push(['$', '$', line, pos - offset]);\n                break;\n\n            case colon:\n                tokens.push([':', ':', line, pos - offset]);\n                break;\n\n            case semicolon:\n                tokens.push([';', ';', line, pos - offset]);\n                break;\n\n            case openBracket:\n                tokens.push(['(', '(', line, pos - offset]);\n                break;\n\n            case closeBracket:\n                tokens.push([')', ')', line, pos - offset]);\n                break;\n\n            case singleQuote:\n            case doubleQuote:\n                quote = code === singleQuote ? \"'\" : '\"';\n                tokens.push([quote, quote, line, pos - offset]);\n                next = pos + 1;\n\n                var _tokenizeString = (0, _tokenizeString3.default)(input, line, next, quote),\n                    t = _tokenizeString.tokens,\n                    _p = _tokenizeString.pos;\n\n                tokens = tokens.concat(t);\n                next = _p;\n\n                pos = next;\n                break;\n\n            case at:\n                tokens.push(['@', '@', line, pos - offset]);\n                break;\n\n            case backslash:\n                next = pos;\n                escape = true;\n                while (css.charCodeAt(next + 1) === backslash) {\n                    next += 1;\n                    escape = !escape;\n                }\n                code = css.charCodeAt(next + 1);\n                if (escape && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {\n                    next += 1;\n                }\n                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n                pos = next;\n                break;\n\n            default:\n                ident.lastIndex = pos;\n                number.lastIndex = pos;\n                wordEnd.lastIndex = pos;\n\n                if (code === slash && css.charCodeAt(pos + 1) === asterisk) {\n                    inComment = true;\n                    tokens.push(['startComment', '/*', line, pos + 1 - offset]);\n                    next = pos + 1;\n\n                    var _tokenizeComment = (0, _tokenizeComment3.default)(input, line, next + 1),\n                        _t = _tokenizeComment.tokens,\n                        _l = _tokenizeComment.line,\n                        _p2 = _tokenizeComment.pos,\n                        o = _tokenizeComment.offset;\n\n                    tokens = tokens.concat(_t);\n                    next = _p2;\n                    line = _l;\n                    offset = o;\n\n                    pos = next;\n                    break;\n                }\n\n                if (code === asterisk && css.charCodeAt(pos + 1) !== slash) {\n                    tokens.push(['*', '*', line, pos - offset]);\n                    break;\n                }\n\n                if (inComment && code === asterisk && css.charCodeAt(pos + 1) === slash) {\n                    inComment = false;\n                    tokens.push(['endComment', '*/', line, pos + 1 - offset]);\n                    pos += 2;\n                    break;\n                }\n\n                if (code === slash && css.charCodeAt(pos + 1) !== slash) {\n                    tokens.push(['/', '/', line, pos - offset]);\n                    break;\n                }\n\n                if (code === hash && css.charCodeAt(pos + 1) === openCurly) {\n                    inInterpolant = true;\n                    tokens.push(['startInterpolant', '#{', line, pos + 1 - offset]);\n                    next = pos + 1;\n\n                    var _tokenizeInterpolant = (0, _tokenizeInterpolant3.default)(input, line, next + 1),\n                        _t2 = _tokenizeInterpolant.tokens,\n                        _p3 = _tokenizeInterpolant.pos;\n\n                    tokens = tokens.concat(_t2);\n                    next = _p3;\n\n                    pos = next;\n                    break;\n                }\n\n                if (code === slash && css.charCodeAt(pos + 1) === slash) {\n                    next = css.indexOf('\\n', pos + 2);\n                    next = (next > 0 ? next : css.length) - 1;\n\n                    tokens.push(['scssComment', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n\n                    pos = next;\n                    break;\n                }\n\n                if (ident.test(css) && (ident.lastIndex = pos || 1) && ident.exec(css).index === pos) {\n                    next = ident.lastIndex - 1;\n\n                    tokens.push(['ident', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n\n                    pos = next;\n                    break;\n                }\n\n                if (number.test(css) && (number.lastIndex = pos || 1) && number.exec(css).index === pos) {\n                    next = number.lastIndex - 1;\n\n                    tokens.push(['number', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n\n                    pos = next;\n                    break;\n                }\n\n                wordEnd.lastIndex = pos + 1;\n                wordEnd.test(css);\n                if (wordEnd.lastIndex === 0) {\n                    next = css.length - 1;\n                } else {\n                    next = wordEnd.lastIndex - 2;\n                }\n\n                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n\n                pos = next;\n\n                break;\n        }\n\n        pos++;\n    }\n\n    return tokens;\n}","\n\nexports.__esModule = true;\nexports.default = tokenize;\n\nvar _input = require('./input');\n\nvar _input2 = _interopRequireDefault(_input);\n\nvar _tokenizeString = require('./tokenize-string');\n\nvar _tokenizeString2 = _interopRequireDefault(_tokenizeString);\n\nvar _tokenizeInterpolant2 = require('./tokenize-interpolant');\n\nvar _tokenizeInterpolant3 = _interopRequireDefault(_tokenizeInterpolant2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar singleQuote = \"'\".charCodeAt(0),\n    doubleQuote = '\"'.charCodeAt(0),\n    newline = '\\n'.charCodeAt(0),\n    space = ' '.charCodeAt(0),\n    feed = '\\f'.charCodeAt(0),\n    tab = '\\t'.charCodeAt(0),\n    cr = '\\r'.charCodeAt(0),\n    hash = '#'.charCodeAt(0),\n    backslash = '\\\\'.charCodeAt(0),\n    slash = '/'.charCodeAt(0),\n    openCurly = '{'.charCodeAt(0),\n    closeCurly = '}'.charCodeAt(0),\n    interpolantEnd = /([.\\s]*?)[^\\\\](?=(}))/gm,\n    sQuoteEnd = /([.\\s]*?)[^\\\\](?=((#{)|'))/gm,\n    dQuoteEnd = /([.\\s]*?)[^\\\\](?=((#{)|\"))/gm;\n\nfunction tokenize(input, l, p, quote) {\n    var tokens = [];\n    var css = input.css.valueOf();\n\n    var code = void 0,\n        next = void 0,\n        lines = void 0,\n        last = void 0,\n        content = void 0,\n        escape = void 0,\n        nextLine = void 0,\n        nextOffset = void 0,\n        escaped = void 0,\n        escapePos = void 0,\n        inInterpolant = void 0,\n        inComment = void 0,\n        inString = void 0;\n\n    var length = css.length;\n    var offset = -1;\n    var line = l || 1;\n    var pos = p || 0;\n\n    var quoteEnd = quote === \"'\" ? sQuoteEnd : dQuoteEnd;\n    var quoteChar = quote.charCodeAt(0);\n\n    loop: while (pos < length) {\n        code = css.charCodeAt(pos);\n\n        if (code === newline) {\n            offset = pos;\n            line += 1;\n        }\n\n        switch (code) {\n\n            case closeCurly:\n                tokens.push(['endInterpolant', '}', line, pos - offset]);\n                break;\n\n            case quoteChar:\n                tokens.push([quote, quote, line, pos - offset]);\n                break loop;\n\n            case backslash:\n                next = pos;\n                escape = true;\n                while (css.charCodeAt(next + 1) === backslash) {\n                    next += 1;\n                    escape = !escape;\n                }\n                code = css.charCodeAt(next + 1);\n                if (escape && code !== slash && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {\n                    next += 1;\n                }\n                tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n                pos = next;\n                break;\n\n            default:\n                if (code === hash && css.charCodeAt(pos + 1) === openCurly) {\n                    tokens.push(['startInterpolant', '#{', line, pos + 1 - offset]);\n                    next = pos + 1;\n\n                    var _tokenizeInterpolant = (0, _tokenizeInterpolant3.default)(input, line, next + 1),\n                        t = _tokenizeInterpolant.tokens,\n                        _p = _tokenizeInterpolant.pos;\n\n                    tokens = tokens.concat(t);\n                    next = _p;\n\n                    pos = next;\n                } else {\n                    quoteEnd.lastIndex = pos;\n                    quoteEnd.test(css);\n\n                    if (quoteEnd.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = quoteEnd.lastIndex - 1;\n                    }\n\n                    tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n\n                    pos = next;\n                }\n\n                break;\n        }\n\n        pos++;\n    }\n\n    return { tokens: tokens, pos: pos };\n}","\n\nexports.__esModule = true;\nexports.default = tokenize;\n\nvar _input = require('./input');\n\nvar _input2 = _interopRequireDefault(_input);\n\nvar _tokenizeString2 = require('./tokenize-string');\n\nvar _tokenizeString3 = _interopRequireDefault(_tokenizeString2);\n\nvar _tokenizeComment2 = require('./tokenize-comment');\n\nvar _tokenizeComment3 = _interopRequireDefault(_tokenizeComment2);\n\nvar _tokenizeInterpolant2 = require('./tokenize-interpolant');\n\nvar _tokenizeInterpolant3 = _interopRequireDefault(_tokenizeInterpolant2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar singleQuote = \"'\".charCodeAt(0),\n    doubleQuote = '\"'.charCodeAt(0),\n    dollar = '$'.charCodeAt(0),\n    hash = '#'.charCodeAt(0),\n    backslash = '\\\\'.charCodeAt(0),\n    slash = '/'.charCodeAt(0),\n    newline = '\\n'.charCodeAt(0),\n    space = ' '.charCodeAt(0),\n    feed = '\\f'.charCodeAt(0),\n    tab = '\\t'.charCodeAt(0),\n    cr = '\\r'.charCodeAt(0),\n    openBracket = '('.charCodeAt(0),\n    closeBracket = ')'.charCodeAt(0),\n    openCurly = '{'.charCodeAt(0),\n    closeCurly = '}'.charCodeAt(0),\n    semicolon = ';'.charCodeAt(0),\n    asterisk = '*'.charCodeAt(0),\n    colon = ':'.charCodeAt(0),\n    at = '@'.charCodeAt(0),\n    comma = ','.charCodeAt(0),\n    plus = '+'.charCodeAt(0),\n    minus = '-'.charCodeAt(0),\n    decComb = '>'.charCodeAt(0),\n    adjComb = '~'.charCodeAt(0),\n    number = /[+-]?(\\d+(\\.\\d+)?|\\.\\d+)|(e[+-]\\d+)/gi,\n    sQuoteEnd = /(.*?)[^\\\\](?=((#{)|'))/gm,\n    dQuoteEnd = /(.*?)[^\\\\](?=((#{)|\"))/gm,\n    wordEnd = /[ \\n\\t\\r\\(\\)\\{\\},:;@!'\"\\\\]|\\/(?=\\*)|#(?={)/g,\n    ident = /-?([a-z_]|\\\\[^\\\\])([a-z-_0-9]|\\\\[^\\\\])*/gi;\n\nfunction tokenize(input, l, p) {\n    var tokens = [];\n    var css = input.css.valueOf();\n\n    var code = void 0,\n        next = void 0,\n        quote = void 0,\n        lines = void 0,\n        last = void 0,\n        content = void 0,\n        escape = void 0,\n        nextLine = void 0,\n        nextOffset = void 0,\n        escaped = void 0,\n        escapePos = void 0,\n        inInterpolant = void 0,\n        inComment = void 0,\n        inString = void 0;\n\n    var length = css.length;\n    var offset = -1;\n    var line = l || 1;\n    var pos = p || 0;\n\n    loop: while (pos < length) {\n        code = css.charCodeAt(pos);\n\n        if (code === newline) {\n            offset = pos;\n            line += 1;\n        }\n\n        switch (code) {\n            case space:\n            case tab:\n            case cr:\n            case feed:\n                next = pos;\n                do {\n                    next += 1;\n                    code = css.charCodeAt(next);\n                    if (code === newline) {\n                        offset = next;\n                        line += 1;\n                    }\n                } while (code === space || code === tab || code === cr || code === feed);\n\n                tokens.push(['space', css.slice(pos, next)]);\n                pos = next - 1;\n                break;\n\n            case newline:\n                tokens.push(['newline', '\\n', line, pos - offset]);\n                break;\n\n            case plus:\n                tokens.push(['+', '+', line, pos - offset]);\n                break;\n\n            case minus:\n                tokens.push(['-', '-', line, pos - offset]);\n                break;\n\n            case decComb:\n                tokens.push(['>', '>', line, pos - offset]);\n                break;\n\n            case adjComb:\n                tokens.push(['~', '~', line, pos - offset]);\n                break;\n\n            case openCurly:\n                tokens.push(['{', '{', line, pos - offset]);\n                break;\n\n            case closeCurly:\n                if (inInterpolant) {\n                    inInterpolant = false;\n                    tokens.push(['endInterpolant', '}', line, pos - offset]);\n                } else {\n                    break loop;\n                }\n                break;\n\n            case comma:\n                tokens.push([',', ',', line, pos - offset]);\n                break;\n\n            case dollar:\n                tokens.push(['$', '$', line, pos - offset]);\n                break;\n\n            case colon:\n                tokens.push([':', ':', line, pos - offset]);\n                break;\n\n            case semicolon:\n                tokens.push([';', ';', line, pos - offset]);\n                break;\n\n            case openBracket:\n                tokens.push(['(', '(', line, pos - offset]);\n                break;\n\n            case closeBracket:\n                tokens.push([')', ')', line, pos - offset]);\n                break;\n\n            case singleQuote:\n            case doubleQuote:\n                quote = code === singleQuote ? \"'\" : '\"';\n                tokens.push([quote, quote, line, pos - offset]);\n                next = pos + 1;\n\n                var _tokenizeString = (0, _tokenizeString3.default)(input, line, next, quote),\n                    t = _tokenizeString.tokens,\n                    _p = _tokenizeString.pos;\n\n                tokens = tokens.concat(t);\n                next = _p;\n\n                pos = next;\n                break;\n\n            case at:\n                tokens.push(['@', '@', line, pos - offset]);\n                break;\n\n            case backslash:\n                next = pos;\n                escape = true;\n                while (css.charCodeAt(next + 1) === backslash) {\n                    next += 1;\n                    escape = !escape;\n                }\n                code = css.charCodeAt(next + 1);\n                if (escape && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {\n                    next += 1;\n                }\n                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n                pos = next;\n                break;\n\n            default:\n                ident.lastIndex = pos;\n                number.lastIndex = pos;\n                wordEnd.lastIndex = pos;\n\n                if (code === slash && css.charCodeAt(pos + 1) === asterisk) {\n                    inComment = true;\n                    tokens.push(['startComment', '/*', line, pos + 1 - offset]);\n                    next = pos + 1;\n\n                    var _tokenizeComment = (0, _tokenizeComment3.default)(input, line, next + 1),\n                        _t = _tokenizeComment.tokens,\n                        _l = _tokenizeComment.line,\n                        _p2 = _tokenizeComment.pos,\n                        o = _tokenizeComment.offset;\n\n                    tokens = tokens.concat(_t);\n                    next = _p2;\n                    line = _l;\n                    offset = o;\n\n                    pos = next;\n                    break;\n                }\n\n                if (code === asterisk && css.charCodeAt(pos + 1) !== slash) {\n                    tokens.push(['*', '*', line, pos - offset]);\n                    break;\n                }\n\n                if (inComment && code === asterisk && css.charCodeAt(pos + 1) === slash) {\n                    inComment = false;\n                    tokens.push(['endComment', '*/', line, pos + 1 - offset]);\n                    pos += 2;\n                    break;\n                }\n\n                if (code === slash && css.charCodeAt(pos + 1) !== slash) {\n                    tokens.push(['/', '/', line, pos - offset]);\n                    pos += 2;\n                    break;\n                }\n\n                if (code === hash && css.charCodeAt(pos + 1) === openCurly) {\n                    inInterpolant = true;\n                    tokens.push(['startInterpolant', '#{', line, pos + 1 - offset]);\n                    next = pos + 1;\n\n                    var _tokenizeInterpolant = (0, _tokenizeInterpolant3.default)(input, line, next + 1),\n                        _t2 = _tokenizeInterpolant.tokens,\n                        _p3 = _tokenizeInterpolant.pos;\n\n                    tokens = tokens.concat(_t2);\n                    next = _p3;\n\n                    pos = next;\n                    break;\n                }\n\n                if (code === slash && css.charCodeAt(pos + 1) === slash) {\n                    next = css.indexOf('\\n\\n', pos + 2);\n                    next = next > 0 ? next : css.length;\n\n                    tokens.push(['scssComment', css.slice(pos, next), line, pos - offset, line, next - offset]);\n\n                    pos = next;\n                    break;\n                }\n\n                if (ident.test(css) && (ident.lastIndex = pos || 1) && ident.exec(css).index === pos) {\n                    next = ident.lastIndex - 1;\n\n                    tokens.push(['ident', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n\n                    pos = next;\n                    break;\n                }\n\n                if (number.test(css) && (number.lastIndex = pos || 1) && number.exec(css).index === pos) {\n                    next = number.lastIndex - 1;\n\n                    tokens.push(['number', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n\n                    pos = next;\n                    break;\n                }\n\n                wordEnd.lastIndex = pos + 1;\n                wordEnd.test(css);\n                if (wordEnd.lastIndex === 0) {\n                    next = css.length - 1;\n                } else {\n                    next = wordEnd.lastIndex - 2;\n                }\n\n                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n\n                pos = next;\n\n                break;\n        }\n\n        pos++;\n    }\n\n    return { tokens: tokens, pos: pos };\n}","\n\nexports.__esModule = true;\nexports.default = tokenize;\n\nvar _input = require('./input');\n\nvar _input2 = _interopRequireDefault(_input);\n\nvar _tokenizeString = require('./tokenize-string');\n\nvar _tokenizeString2 = _interopRequireDefault(_tokenizeString);\n\nvar _tokenizeInterpolant2 = require('./tokenize-interpolant');\n\nvar _tokenizeInterpolant3 = _interopRequireDefault(_tokenizeInterpolant2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar newline = '\\n'.charCodeAt(0),\n    space = ' '.charCodeAt(0),\n    feed = '\\f'.charCodeAt(0),\n    tab = '\\t'.charCodeAt(0),\n    cr = '\\r'.charCodeAt(0),\n    hash = '#'.charCodeAt(0),\n    backslash = '\\\\'.charCodeAt(0),\n    slash = '/'.charCodeAt(0),\n    openCurly = '{'.charCodeAt(0),\n    closeCurly = '}'.charCodeAt(0),\n    asterisk = '*'.charCodeAt(0),\n    wordEnd = /[ \\n\\t\\r\\(\\)\\{\\},:;@!'\"\\\\]|\\*(?=\\/)|#(?={)/g;\n\nfunction tokenize(input, l, p) {\n    var tokens = [];\n    var css = input.css.valueOf();\n\n    var code = void 0,\n        next = void 0,\n        lines = void 0,\n        last = void 0,\n        content = void 0,\n        escape = void 0,\n        nextLine = void 0,\n        nextOffset = void 0,\n        escaped = void 0,\n        escapePos = void 0,\n        inInterpolant = void 0,\n        inComment = void 0,\n        inString = void 0;\n\n    var length = css.length;\n    var offset = -1;\n    var line = l || 1;\n    var pos = p || 0;\n\n    loop: while (pos < length) {\n        code = css.charCodeAt(pos);\n\n        if (code === newline) {\n            offset = pos;\n            line += 1;\n        }\n\n        switch (code) {\n            case space:\n            case tab:\n            case cr:\n            case feed:\n                next = pos;\n                do {\n                    next += 1;\n                    code = css.charCodeAt(next);\n                    if (code === newline) {\n                        offset = next;\n                        line += 1;\n                    }\n                } while (code === space || code === tab || code === cr || code === feed);\n\n                tokens.push(['space', css.slice(pos, next)]);\n                pos = next - 1;\n                break;\n\n            case newline:\n                tokens.push(['newline', '\\n', line, pos - offset]);\n                break;\n\n            case closeCurly:\n                tokens.push(['endInterpolant', '}', line, pos - offset]);\n                break;\n\n            case backslash:\n                next = pos;\n                escape = true;\n                while (css.charCodeAt(next + 1) === backslash) {\n                    next += 1;\n                    escape = !escape;\n                }\n                code = css.charCodeAt(next + 1);\n                if (escape && code !== slash && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {\n                    next += 1;\n                }\n                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n                pos = next;\n                break;\n\n            default:\n\n                if (code === asterisk && css.charCodeAt(pos + 1) === slash) {\n                    next = pos;\n                    pos = next - 1;\n                    break loop;\n                }\n\n                if (code === hash && css.charCodeAt(pos + 1) === openCurly) {\n                    tokens.push(['startInterpolant', '#{', line, pos + 1 - offset]);\n                    next = pos + 1;\n\n                    var _tokenizeInterpolant = (0, _tokenizeInterpolant3.default)(input, line, next + 1),\n                        t = _tokenizeInterpolant.tokens,\n                        _p = _tokenizeInterpolant.pos;\n\n                    tokens = tokens.concat(t);\n                    next = _p;\n\n                    pos = next;\n                    break;\n                }\n\n                wordEnd.lastIndex = pos + 1;\n                wordEnd.test(css);\n                if (wordEnd.lastIndex === 0) {\n                    next = css.length - 1;\n                } else {\n                    next = wordEnd.lastIndex - 2;\n                }\n\n                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n\n                pos = next;\n\n                break;\n        }\n\n        pos++;\n    }\n\n    return { tokens: tokens, line: line, pos: pos, offset: offset };\n}"]}