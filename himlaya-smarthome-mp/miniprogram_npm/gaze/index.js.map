{"version":3,"sources":["gaze.js","helper.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n * gaze\n * https://github.com/shama/gaze\n *\n * Copyright (c) 2018 Kyle Robinson Young\n * Licensed under the MIT license.\n */\n\n\n\n// libs\nvar util = require('util');\nvar EE = require('events').EventEmitter;\nvar fs = require('fs');\nvar path = require('path');\nvar globule = require('globule');\nvar helper = require('./helper');\n\n// shim setImmediate for node v0.8\nvar setImmediate = require('timers').setImmediate;\nif (typeof setImmediate !== 'function') {\n  setImmediate = process.nextTick;\n}\n\n// globals\nvar delay = 10;\n\n// `Gaze` EventEmitter object to return in the callback\nfunction Gaze (patterns, opts, done) {\n  var self = this;\n  EE.call(self);\n\n  // If second arg is the callback\n  if (typeof opts === 'function') {\n    done = opts;\n    opts = {};\n  }\n\n  // Default options\n  opts = opts || {};\n  opts.mark = true;\n  opts.interval = opts.interval || 100;\n  opts.debounceDelay = opts.debounceDelay || 500;\n  opts.cwd = opts.cwd || process.cwd();\n  this.options = opts;\n\n  // Default done callback\n  done = done || function () {};\n\n  // Remember our watched dir:files\n  this._watched = Object.create(null);\n\n  // Store watchers\n  this._watchers = Object.create(null);\n\n  // Store watchFile listeners\n  this._pollers = Object.create(null);\n\n  // Store patterns\n  this._patterns = [];\n\n  // Cached events for debouncing\n  this._cached = Object.create(null);\n\n  // Set maxListeners\n  if (this.options.maxListeners != null) {\n    this.setMaxListeners(this.options.maxListeners);\n    Gaze.super_.prototype.setMaxListeners(this.options.maxListeners);\n    delete this.options.maxListeners;\n  }\n\n  // Initialize the watch on files\n  if (patterns) {\n    this.add(patterns, done);\n  }\n\n  // keep the process alive\n  this._keepalive = setInterval(function () {}, 200);\n\n  return this;\n}\nutil.inherits(Gaze, EE);\n\n// Main entry point. Start watching and call done when setup\nmodule.exports = function gaze (patterns, opts, done) {\n  return new Gaze(patterns, opts, done);\n};\nmodule.exports.Gaze = Gaze;\n\n// Override the emit function to emit `all` events\n// and debounce on duplicate events per file\nGaze.prototype.emit = function () {\n  var self = this;\n  var args = arguments;\n\n  var e = args[0];\n  var filepath = args[1];\n  var timeoutId;\n\n  // If not added/deleted/changed/renamed then just emit the event\n  if (e.slice(-2) !== 'ed') {\n    Gaze.super_.prototype.emit.apply(self, args);\n    return this;\n  }\n\n  // Detect rename event, if added and previous deleted is in the cache\n  if (e === 'added') {\n    Object.keys(this._cached).forEach(function (oldFile) {\n      if (self._cached[oldFile].indexOf('deleted') !== -1) {\n        args[0] = e = 'renamed';\n        [].push.call(args, oldFile);\n        delete self._cached[oldFile];\n        return false;\n      }\n    });\n  }\n\n  // If cached doesnt exist, create a delay before running the next\n  // then emit the event\n  var cache = this._cached[filepath] || [];\n  if (cache.indexOf(e) === -1) {\n    helper.objectPush(self._cached, filepath, e);\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(function () {\n      delete self._cached[filepath];\n    }, this.options.debounceDelay);\n    // Emit the event and `all` event\n    Gaze.super_.prototype.emit.apply(self, args);\n    Gaze.super_.prototype.emit.apply(self, ['all', e].concat([].slice.call(args, 1)));\n  }\n\n  // Detect if new folder added to trigger for matching files within folder\n  if (e === 'added') {\n    if (helper.isDir(filepath)) {\n      // It's possible that between `isDir` and `readdirSync()` calls the `filepath`\n      // gets removed, which will result in `ENOENT` exception\n\n      var files;\n\n      try {\n        files = fs.readdirSync(filepath);\n      } catch (e) {\n        // Rethrow the error if it's anything other than `ENOENT`\n        if (e.code !== 'ENOENT') {\n          throw e;\n        }\n\n        files = [];\n      }\n\n      files.map(function (file) {\n        return path.join(filepath, file);\n      }).filter(function (file) {\n        return globule.isMatch(self._patterns, file, self.options);\n      }).forEach(function (file) {\n        self.emit('added', file);\n      });\n    }\n  }\n\n  return this;\n};\n\n// Close watchers\nGaze.prototype.close = function (_reset) {\n  var self = this;\n  Object.keys(self._watchers).forEach(function (file) {\n    self._watchers[file].close();\n  });\n  self._watchers = Object.create(null);\n  Object.keys(this._watched).forEach(function (dir) {\n    self._unpollDir(dir);\n  });\n  if (_reset !== false) {\n    self._watched = Object.create(null);\n    setTimeout(function () {\n      self.emit('end');\n      self.removeAllListeners();\n      clearInterval(self._keepalive);\n    }, delay + 100);\n  }\n  return self;\n};\n\n// Add file patterns to be watched\nGaze.prototype.add = function (files, done) {\n  if (typeof files === 'string') { files = [files]; }\n  this._patterns = helper.unique.apply(null, [this._patterns, files]);\n  files = globule.find(this._patterns, this.options);\n  this._addToWatched(files);\n  this.close(false);\n  this._initWatched(done);\n};\n\n// Dont increment patterns and dont call done if nothing added\nGaze.prototype._internalAdd = function (file, done) {\n  var files = [];\n  if (helper.isDir(file)) {\n    files = [helper.markDir(file)].concat(globule.find(this._patterns, this.options));\n  } else {\n    if (globule.isMatch(this._patterns, file, this.options)) {\n      files = [file];\n    }\n  }\n  if (files.length > 0) {\n    this._addToWatched(files);\n    this.close(false);\n    this._initWatched(done);\n  }\n};\n\n// Remove file/dir from `watched`\nGaze.prototype.remove = function (file) {\n  var self = this;\n  if (this._watched[file]) {\n    // is dir, remove all files\n    this._unpollDir(file);\n    delete this._watched[file];\n  } else {\n    // is a file, find and remove\n    Object.keys(this._watched).forEach(function (dir) {\n      var index = self._watched[dir].indexOf(file);\n      if (index !== -1) {\n        self._unpollFile(file);\n        self._watched[dir].splice(index, 1);\n        return false;\n      }\n    });\n  }\n  if (this._watchers[file]) {\n    this._watchers[file].close();\n  }\n  return this;\n};\n\n// Return watched files\nGaze.prototype.watched = function () {\n  return this._watched;\n};\n\n// Returns `watched` files with relative paths to process.cwd()\nGaze.prototype.relative = function (dir, unixify) {\n  var self = this;\n  var relative = Object.create(null);\n  var relDir, relFile, unixRelDir;\n  var cwd = this.options.cwd || process.cwd();\n  if (dir === '') { dir = '.'; }\n  dir = helper.markDir(dir);\n  unixify = unixify || false;\n  Object.keys(this._watched).forEach(function (dir) {\n    relDir = path.relative(cwd, dir) + path.sep;\n    if (relDir === path.sep) { relDir = '.'; }\n    unixRelDir = unixify ? helper.unixifyPathSep(relDir) : relDir;\n    relative[unixRelDir] = self._watched[dir].map(function (file) {\n      relFile = path.relative(path.join(cwd, relDir) || '', file || '');\n      if (helper.isDir(file)) {\n        relFile = helper.markDir(relFile);\n      }\n      if (unixify) {\n        relFile = helper.unixifyPathSep(relFile);\n      }\n      return relFile;\n    });\n  });\n  if (dir && unixify) {\n    dir = helper.unixifyPathSep(dir);\n  }\n  return dir ? relative[dir] || [] : relative;\n};\n\n// Adds files and dirs to watched\nGaze.prototype._addToWatched = function (files) {\n  var dirs = [];\n\n  for (var i = 0; i < files.length; i++) {\n    var file = files[i];\n    var filepath = path.resolve(this.options.cwd, file);\n\n    var dirname = (helper.isDir(file)) ? filepath : path.dirname(filepath);\n    dirname = helper.markDir(dirname);\n\n    // If a new dir is added\n    if (helper.isDir(file) && !(dirname in this._watched)) {\n      helper.objectPush(this._watched, dirname, []);\n    }\n\n    if (file.slice(-1) === '/') { filepath += path.sep; }\n    helper.objectPush(this._watched, path.dirname(filepath) + path.sep, filepath);\n\n    dirs.push(dirname);\n  }\n\n  dirs = helper.unique(dirs);\n\n  for (var k = 0; k < dirs.length; k++) {\n    dirname = dirs[k];\n    // add folders into the mix\n    var readdir = fs.readdirSync(dirname);\n    for (var j = 0; j < readdir.length; j++) {\n      var dirfile = path.join(dirname, readdir[j]);\n      if (fs.lstatSync(dirfile).isDirectory()) {\n        helper.objectPush(this._watched, dirname, dirfile + path.sep);\n      }\n    }\n  }\n\n  return this;\n};\n\nGaze.prototype._watchDir = function (dir, done) {\n  var self = this;\n  var timeoutId;\n  try {\n    this._watchers[dir] = fs.watch(dir, function (event) {\n      // race condition. Let's give the fs a little time to settle down. so we\n      // don't fire events on non existent files.\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(function () {\n        // race condition. Ensure that this directory is still being watched\n        // before continuing.\n        if ((dir in self._watchers) && fs.existsSync(dir)) {\n          done(null, dir);\n        }\n      }, delay + 100);\n    });\n\n    this._watchers[dir].on('error', function (err) {\n      self._handleError(err);\n    });\n  } catch (err) {\n    return this._handleError(err);\n  }\n  return this;\n};\n\nGaze.prototype._unpollFile = function (file) {\n  if (this._pollers[file]) {\n    fs.unwatchFile(file, this._pollers[file]);\n    delete this._pollers[file];\n  }\n  return this;\n};\n\nGaze.prototype._unpollDir = function (dir) {\n  this._unpollFile(dir);\n  for (var i = 0; i < this._watched[dir].length; i++) {\n    this._unpollFile(this._watched[dir][i]);\n  }\n};\n\nGaze.prototype._pollFile = function (file, done) {\n  var opts = { persistent: true, interval: this.options.interval };\n  if (!this._pollers[file]) {\n    this._pollers[file] = function (curr, prev) {\n      done(null, file);\n    };\n    try {\n      fs.watchFile(file, opts, this._pollers[file]);\n    } catch (err) {\n      return this._handleError(err);\n    }\n  }\n  return this;\n};\n\n// Initialize the actual watch on `watched` files\nGaze.prototype._initWatched = function (done) {\n  var self = this;\n  var cwd = this.options.cwd || process.cwd();\n  var curWatched = Object.keys(self._watched);\n\n  // if no matching files\n  if (curWatched.length < 1) {\n    // Defer to emitting to give a chance to attach event handlers.\n    setImmediate(function () {\n      self.emit('ready', self);\n      if (done) { done.call(self, null, self); }\n      self.emit('nomatch');\n    });\n    return;\n  }\n\n  helper.forEachSeries(curWatched, function (dir, next) {\n    dir = dir || '';\n    var files = self._watched[dir];\n    // Triggered when a watched dir has an event\n    self._watchDir(dir, function (event, dirpath) {\n      var relDir = cwd === dir ? '.' : path.relative(cwd, dir);\n      relDir = relDir || '';\n\n      fs.readdir(dirpath, function (err, current) {\n        if (err) { return self.emit('error', err); }\n        if (!current) { return; }\n\n        try {\n          // append path.sep to directories so they match previous.\n          current = current.map(function (curPath) {\n            if (fs.existsSync(path.join(dir, curPath)) && fs.lstatSync(path.join(dir, curPath)).isDirectory()) {\n              return curPath + path.sep;\n            } else {\n              return curPath;\n            }\n          });\n        } catch (err) {\n          // race condition-- sometimes the file no longer exists\n        }\n\n        // Get watched files for this dir\n        var previous = self.relative(relDir);\n\n        // If file was deleted\n        previous.filter(function (file) {\n          return current.indexOf(file) < 0;\n        }).forEach(function (file) {\n          if (!helper.isDir(file)) {\n            var filepath = path.join(dir, file);\n            self.remove(filepath);\n            self.emit('deleted', filepath);\n          }\n        });\n\n        // If file was added\n        current.filter(function (file) {\n          return previous.indexOf(file) < 0;\n        }).forEach(function (file) {\n          // Is it a matching pattern?\n          var relFile = path.join(relDir, file);\n          // Add to watch then emit event\n          self._internalAdd(relFile, function () {\n            self.emit('added', path.join(dir, file));\n          });\n        });\n      });\n    });\n\n    // Watch for change/rename events on files\n    files.forEach(function (file) {\n      if (helper.isDir(file)) { return; }\n      self._pollFile(file, function (err, filepath) {\n        if (err) {\n          self.emit('error', err);\n          return;\n        }\n        // Only emit changed if the file still exists\n        // Prevents changed/deleted duplicate events\n        if (fs.existsSync(filepath)) {\n          self.emit('changed', filepath);\n        }\n      });\n    });\n\n    next();\n  }, function () {\n    // Return this instance of Gaze\n    // delay before ready solves a lot of issues\n    setTimeout(function () {\n      self.emit('ready', self);\n      if (done) { done.call(self, null, self); }\n    }, delay + 100);\n  });\n};\n\n// If an error, handle it here\nGaze.prototype._handleError = function (err) {\n  if (err.code === 'EMFILE') {\n    return this.emit('error', new Error('EMFILE: Too many opened files.'));\n  }\n  return this.emit('error', err);\n};\n","\n\nvar path = require('path');\nvar helper = module.exports = {};\n\n// Returns boolean whether filepath is dir terminated\nhelper.isDir = function isDir (dir) {\n  if (typeof dir !== 'string') {\n    return false;\n  }\n  return (dir.slice(-(path.sep.length)) === path.sep);\n};\n\n// Create a `key:[]` if doesnt exist on `obj` then push or concat the `val`\nhelper.objectPush = function objectPush (obj, key, val) {\n  if (obj[key] == null) {\n    obj[key] = [];\n  }\n  if (Array.isArray(val)) {\n    obj[key] = obj[key].concat(val);\n  } else if (val) {\n    obj[key].push(val);\n  }\n  obj[key] = helper.unique(obj[key]);\n  return obj[key];\n};\n\n// Ensures the dir is marked with path.sep\nhelper.markDir = function markDir (dir) {\n  if (typeof dir === 'string' &&\n    dir.slice(-(path.sep.length)) !== path.sep &&\n    dir !== '.') {\n    dir += path.sep;\n  }\n  return dir;\n};\n\n// Changes path.sep to unix ones for testing\nhelper.unixifyPathSep = function unixifyPathSep (filepath) {\n  return (process.platform === 'win32') ? String(filepath).replace(/\\\\/g, '/') : filepath;\n};\n\n/**\n * Lo-Dash 1.0.1 <http://lodash.com/>\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.4.4 <http://underscorejs.org/>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n * Available under MIT license <http://lodash.com/license>\n */\nhelper.unique = function unique () {\n  var array = Array.prototype.concat.apply(Array.prototype, arguments);\n  var result = [];\n  for (var i = 0; i < array.length; i++) {\n    if (result.indexOf(array[i]) === -1) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Copyright (c) 2010 Caolan McMahon\n * Available under MIT license <https://raw.github.com/caolan/async/master/LICENSE>\n */\nhelper.forEachSeries = function forEachSeries (arr, iterator, callback) {\n  if (!arr.length) { return callback(); }\n  var completed = 0;\n  var iterate = function () {\n    iterator(arr[completed], function (err) {\n      if (err) {\n        callback(err);\n        callback = function () {};\n      } else {\n        completed += 1;\n        if (completed === arr.length) {\n          callback(null);\n        } else {\n          iterate();\n        }\n      }\n    });\n  };\n  iterate();\n};\n"]}